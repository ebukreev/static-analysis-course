#let project(title: "", authors: (), body) = {
  set document(author: authors, title: title)
  set page(numbering: "1", number-align: center)
  set text(font: "Linux Libertine", lang: "ru")

  align(center)[
    #block(text(weight: 700, 1.75em, title))
  ]

  pad(
    top: 0.5em,
    bottom: 0.5em,
    x: 2em,
    grid(
      columns: (1fr,) * calc.min(3, authors.len()),
      gutter: 1em,
      ..authors.map(author => align(center, strong(author))),
    ),
  )

  set par(justify: true)

  body
}

#show: project.with(
  title: "Ответы на вопросы с лекций",
  authors: (
    "Евгений Букреев",
  ),
)

= 02-simple

  \
  1. Что будет, если в нашу систему ввести тип Bool?
  Перепишем правила (те, которые не выписаны, оставлены без изменений):

  #align(center)[
  $E_1 > E_2: [|E_1|] = [|E_2|] = "int" and [|E_1 > E_2|] = "bool"$\
  $E_1 == E_2: [|E_1|] = [|E_2|] and [|E_1==E_2|] = "bool"$\
  $E_1 op E_2: [|E_1|] = [|E_2|] = [|E_1 op E_2|] = "int"$\
  $"output" E: [|E|] = alpha$\
  $"if" (E) S: [|E|] = "bool"$\
  $"if" (E) S_1 "else" S_2: [|E|] = "bool"$\
  $"while" (E) S: [|E|] = "bool"$]
  
  Полученный анализ не изменит точность, потому что он был и есть soundness. Но снизится полнота, потому что станут отвергаться некоторые выражения, которые имеют корректную семантику. Например, (x == y) + 1.
  
  \

  2. Что будет, если в нашу систему ввести тип Array?
  Дополним правила типизации новыми конструкциями. Старые остались без изменений.

    #align(center)[
    ${} : [| {} |] = alpha[]$\
    ${E_1,...,E_n} : [|E_1|] = ... = [|E_n|] and [| {E_1,...,E_n} |] = [|E_1|][]$\
    $E[E_1] : [|E|] = alpha[] and [|E_1|] = "int" and [|E[E_1]|] = alpha$\
    $E[E_1] = E_2 : [|E|] = alpha[] and [|E_1|] = "int" and [|E_2|] = alpha$]

    Протипизируем программу со слайда:
  #align(center)[
    ```c
    main() {
      var x,y,z,t;
      x = {2,4,8,16,32,64}; // [|x|] = [|{2,4,8,16,32,64}|]
      y = x[x[3]];          // [|y|] = [|x[x[3]]|]
      z = {{},x};           // [|z|] = [|{{},x}|]
      t = z[1];             // [|t|] = [|z[1]|]
      t[2] = y;             // [|t|] = alpha[] and [|y|] = alpha
    }
    ```]

    Решим уравнения:
      #align(center)[
    $[|x|] = "int"[]$\
    $[|y|] = "int"$\
    $[|z|] = "int[][]"$\
    $[|t|] = "int[]"$\
  ]

  3. Подумайте, что происходит в получившейся реализации, если в программе есть рекурсивный тип? 

  Тогда программа все равно типизируется, т.к. используется регулярная унификация на основе Union-Find и регулярные рекурсивные термы разрешены.

  #pagebreak()

= 03-lattices

\

1. Как выглядит $union.sq L_1 × L_2 × . . . × L_n$? $ (top L_1, top L_2, ... top L_n)$. Нижняя аналогично:  $ (bot L_1, bot L_2, ... bot L_n)$

2. Какая высота произведения решеток? Она равна сумме высот производящих решеток. Так как самый длинный путь от $top$ до $bot$ будет проходить через самые длинные пути исходных решеток.

3. Для решетки отображений $A -> L$ точная верхняя грань это отображение $forall a : A. a -> top$, а точная нижняя $forall a : A.a -> bot$.

4. Решетку отображений $A -> L$ можно выразить как $L^n$, где n = sizeof(A), поэтому $"height"(A -> L) = "height(L)" * "sizeof"(A)$

5. Можно ли выразить анализ типов с предыдущей лекции как анализ над решетками? Да, если взять решетку flat от множества возможных типов, где $bot$ представляет полиморфную типовую переменнную, а $top$ ошибку типизации.

6. Можно ли выразить анализ над решетками как анализ типов? Да, если мы сами выбираем систему типов. Тогда необходимо явно ввести $top$ (в разных языках это Any, Object...) и $bot$ (Nothing). Отношение выражается через subtyping.

= 04-flow

\
 
1. Какова сложность структурного алгоритма для live variables analysis? Сложность структурного алгоритма в общем случае это O(n · h · k), где n -- количество узлов CFG, h -- высота решетки, а k -- время вычисления constraint функции. Тогда для live variables analysis с n узлами и b переменными k = O(b), а ответом будет O(n · b · b). Наличие циклов не меняет оценку.
2. Сложность по памяти O(b) т.к. храним состояние для текущего узла CFG и следующих const узлов.

#pagebreak()

= 05-intervals

\

Для вычисления возможных размеров переменных требуется знать интервал значений, которые эта переменная может достигать в процессе выполнения программы. Для представления этих значений необходимо взять интервальную решетку целых чисел. 

Для практических же целей, чтобы получить конечную версию решетки, добавим операцию widening, которая будет аппроксимировать значения до краевых значений предложенных типов. [0, 1] для bool, [$-2^8, 2^8-1$] для short, ... [$-infinity, +infinity$] для bigint или any.

Также для целей анализа нам потребуется решетка отображений $"Vars" -> "Intervals"$.

= 06-path

\

1. Напишите вариант программы, для которой анализ открытости-закрытости файлов не показывает корректный результат даже с учётом всех возможных условий в переходах.

  #align(center)[
    ```c
    main() {
      var flag;
      input(flag)

      if (flag) {
        open();
      }

      if (flag) {
        close();
      }
    }
    ```]

Проблема заключается в том, что значение флага приходит извне. А наш анализ не может доказать, что поведение программы всегда корректно.

2. Предложите, каким образом можно решить описанные в лекции проблемы в этой ситуации.

Для случаев, когда на интересующее нас поведение влияют неизвестные значения, необходимо разбить эти значения на классы эквивалентности и провести анализ для каждого из них. Удастся либо доказать невозможность какого то факта, либо найти контрпример.